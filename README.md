
# Бинарный транслятор

## Введение

В прошлом семестре мы написали свой язык программирования ( [triple 'p'](https://github.com/4EFI/Language) ). Язык, который плюсовее плюсов, ведь это плюс плюс плюс :)) Написанный язык выполнялся на нами реализованном [процессоре](https://github.com/4EFI/CPU). В этой работе нам предстоит транслировать наш бинарный код в бинарный код архитектуры x86-64.

<p style="text-align: center"><img src=res/bin.png width="650px"/></p>

## Реализация трансляции

### Начало начал. База базная 

Сперва, давайте углубимся в структуру команд нашего процессора. Первый байт, а именно первые 5 бит отвечают за "cmd num", за номер соответствующей команды (0-31), далее следует бит "imm", бит который показывает, оперирует ли команда со значениями, следующий бит - "reg" - будет ли присутствовать регистр, последний бит "mem" показывает, будут ли производится действия с оперативной памяти. Изобразим это схематично: 

<p style="text-align: center"><img src=res/cmd.png width="300px"/></p>

После байта команды, следует байт "reg num", отвечающий за номер регистра, если бит "reg" выставлен в 1. Затем следуют 8 байт, значение типа double, если бит "imm" выставлен в 1.

<p style="text-align: center"><img src=res/full_cmd.png width="600px"/></p>

Теперь приведу пример листинга ассемблерного кода, для лучшего представления структуры команд:

<p style="text-align: center"><img src=res/example_asm.png width="600px"/></p>

После того, как мы имеем представление о том, как ассемблерный код переводится в машинный, давайте считаем наш бинарник, предварительно сравнив сигнатуру и версию, и разобьем его на массив структур, следующего вида:

```C++
struct Command
{
    CMD cmd;

    int    reg_num;
    double val;
};
```

Это сильно упрощает процесс обработки команд, также нам не нужно будет каждый раз обращаться к файлу, что очень затратно, мы один раз считаем его полностью и забудем. Таким образом мы реализовали [IR](https://www.mono-project.com/docs/advanced/runtime/docs/linear-ir/) (кхм..кхм.. итс интермидиат репрезентатион ). 

Перед тем как начать транслировать в машинный код архитектуры x86-64, стоит отметить, что мой процессор написан на значениях типа double. Для того чтобы производить арифметические операции над ними, будем использовать xmm регистры. 

Перейдем к следующему этапу, непосредственно к трансляции.

### Push/Pop. Или как владик со стеком баловался

Я бы сказал, это одна из самых сложных частей, ведь нам предстоит решить сразу несколько задач. Начнем с простого, трансляции **push r_x**, где r_x это один из регистров (rax, rcx, rdx, rbx). Это транслируется соответственно в **push r_x**. 

> Стоит оговориться, что трансляция производится на бинарном уровне, лишь для простоты, я описываю трансляцию на ассемблере. 


