
Стоит сразу оговориться, что работа будет состоять из двух частей. В первой части мы напишем JIT компилятор, а во второй - полноценный бинарный транслятор с записью в ELF (Executable and Linkable Format) файл.

# Часть 1. JIT-компиляция

## Введение

В прошлом семестре мы написали свой язык программирования ( [triple 'p'](https://github.com/4EFI/Language) ). Язык, который плюсовее плюсов, ведь это плюс плюс плюс :)) Написанный язык выполнялся на нами реализованном [процессоре](https://github.com/4EFI/CPU). В этой работе нам предстоит транслировать наш бинарный код в бинарный код архитектуры x86-64.

<p style="text-align: center"><img src=res/bin.png width="750px"/></p>

## Реализация трансляции

### Начало начал. База базная 

Сперва, давайте углубимся в структуру команд нашего процессора. Первый байт, а именно первые 5 бит отвечают за "cmd num", за номер соответствующей команды (0-31), далее следует бит "imm", бит который показывает, оперирует ли команда со значениями, следующий бит - "reg" - будет ли присутствовать регистр, последний бит "mem" показывает, будут ли производится действия с оперативной памяти. Изобразим это схематично: 

<p style="text-align: center"><img src=res/cmd.png width="300px"/></p>

После байта команды, следует байт "reg num", отвечающий за номер регистра, если бит "reg" выставлен в 1. Затем следуют 8 байт, значение типа double, если бит "imm" выставлен в 1.

<p style="text-align: center"><img src=res/full_cmd.png width="600px"/></p>

Теперь приведу пример листинга ассемблерного кода, для лучшего представления структуры команд:

<p style="text-align: center"><img src=res/example_asm.png width="600px"/></p>

После того, как мы имеем представление о том, как ассемблерный код переводится в машинный, давайте считаем наш бинарник, предварительно сравнив сигнатуру и версию, и разобьем его на массив структур, следующего вида:

```C++
struct Command
{
    CMD cmd;

    int    reg_num;
    double val;
};
```

Это сильно упрощает процесс обработки команд, также нам не нужно будет каждый раз обращаться к файлу, что очень затратно, мы один раз считаем его полностью и забудем. Таким образом мы реализовали [IR](https://www.mono-project.com/docs/advanced/runtime/docs/linear-ir/) (кхм..кхм.. итс интермидиат репрезентатион ). 

Перед тем как начать транслировать в машинный код архитектуры x86-64, стоит отметить, что мой процессор написан на значениях типа double. Для того чтобы производить арифметические операции над ними, будем использовать xmm регистры и соответствующие ассемблерные команды. 

Перейдем к следующему этапу, непосредственно к трансляции.

### Push/Pop. Или как Владос со стеком баловался

Я бы сказал, это одна из самых сложных частей, ведь нам предстоит решить сразу несколько задач. Начнем с простого, трансляции **push r_x**, где r_x это один из регистров (rax, rcx, rdx, rbx). Это транслируется соответственно в **push r_x**. Пока ничего сложного. 

> Стоит оговориться, что трансляция производится на бинарном уровне, и лишь для простоты, я описываю трансляцию на ассемблере. 

В моем процессоре была реализована возможность пушить числа в сумме с регистром, разберем на примере **push rax + 10.0**. В этом случае трансляции производится так, сначала с помощью **movsd** мы загружаем 10.0 и rax в регистры xmm0 и xmm1 соответственно, затем ассемблерной командой **addsd** складываем их и пушим результат.   

А что делать если мы встречаем команду **push [rax + 10.0]**. Во первых нам нужно выделить место под оперативную память, как мы это делали в нашем процессоре. Для это мы просто создадим массив на N элементов (где N, заранее определенная константа). Теперь мы должны конвертировать сумму rax и 10.0 из double в int при помощи **cvttsd2si**. А затем прибавляем адрес начала оперативной памяти и выполняем **mov qword m, r**.

После того как мы реализовали **push**, разрешили множество проблем, которые встретились нам на пути, с **pop** проблем не возникло и сделали все по аналогии. 

> Рубрика не баг а фича. Так как процессор написан на даблах, я оставил возможность push [rax + 0.5], что именно он запушет, я предоставляю возможность разобраться читателю. 

### Арифметика. История о том, как Перец считать учился

В моем процессоре была реализована возможность умножения, деления, сложения и вычитания. Для того, чтобы например сложить 2 и 5 на моей ассемблера, сначала производим push 2 и push 5, а затем команду add, которая запушит 7 в стек, вместо 2 и 5. Так как push и pop мы уже реализовали, нам осталось реализовать арифметику. Для этого загружаем числа из стека в xmm0 и xmm1 соответственно, выполняем нужную нам команду **addsd**, **subsd**, **mulsd**, **divsd** и загружаем обратно в стек.

### Условные и безусловные джампы. Джамп джамп

Так как адресация в моем процессоре и x86-64 отличается, нам нужно придумать как решить эту проблему. Я к этому подошел следующим образом, сначала я добавил в структуру положение команды относительно моего бинарника и x86-64:

```C++
struct Command
{
    ...

    int   bin_code_pos;
    char* bin_code_x86_ptr;
};
```

Перед началом обработки команд, мы создаем таблицу джампов. Как только мы встречаем **jmp**, мы транслируем это как jmp ... и добавляем в таблицу указатель на начала пропуска и указатель на позицию в которую будет производиться джамп. По завершению обработки всех команд, мы проходимся по этой таблице и заполняем пропуски. 

Для того, чтобы реализовать условные переходы, нам предстоит загрузить в xmm0 и xmm1 регистры значения из стека, сравнить их с помощью **cmpsd xmm0, xmm1, TYPE** и в зависимости от результата выполнить переход или нет.

### Call/Ret. Меня вызывали?

При трансляции вызова функции, я столкнулся с проблемой, что в моем процессоре было 2 стека, один из использовался для значений, второй для адресов возврата. В этом случае, если будем использовать лишь один системный стек в x86-64, то при стековой передаче параметров в функцию, будет браться адрес возврата вместо адреса нужных переменных. Поэтому я добавил еще один стек для возвратов, как в своем процессоре. И адресы возврата пушу именно туда. Все остальное выполняется по аналогии. 

Ret транслируется следующим образом, выпопливается значение со стека возвратов в системный стек и выполняется ret. 

### Вывод. Да не тот вывод, а в консоль

Для вывода я решил осмелиться и использовать свой ранее написанный [printf](https://github.com/4EFI/Printf). Правда он работает на целых числах, но ничего, просто конвертируем из double в int и проблем нет, ну точность неем-м-н-о-о-о-о-го теряется, подумаешь.  

# Часть 2. Бинарный транслятор

## Заключение

Конечно, я описал лишь основную логику трансляции команд, более подробнее вы можешь ознакомиться, покопавшись непосредственно в [коде](https://github.com/4EFI/BinaryTranslator/blob/main/LngHandler/execution/include/commands.h). Как только у меня получилось транслировать свой язык, я почувствовал себя богом си и асма :))  


